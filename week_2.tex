%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage{fancyvrb}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[colorinlistoftodos]{todonotes}

\setlength{\parskip}{0.4em}

%----------------------------------------------------------------------------------------
%   HEADING
%----------------------------------------------------------------------------------------

\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\left(#1\right)}}

\title{\textsc{Software Engineering}\\Working With Legacy Code}
\author{Lawrence Jones \{lmj112\} \  Alice Sibold \{as4712\} \\
        Joshua Coutinho \{jrc12\}}

\date{}
\begin{document}
\maketitle

%----------------------------------------------------------------------------------------
%   BODY
%----------------------------------------------------------------------------------------

\subsection*{What is the main thing that makes working with legacy code a
difficult job?}

The main problem with maintaining legacy code is that it has typically outgrown
the foundations that were put in place during its active development.
Compounding this, developers who are asked to work with the legacy platform lack
the context required to see the intended architecture beneath this growth, and
underestimate the valuable knowledge it encodes.

When code is legacy, it has been around for some time. Lehman's law of
`Continuing Change'~\cite{lehman} specifies that a system must be continually
adapted or become increasingly less satisfactory. As a result of this gentle yet
persistent pressure, legacy code undergoes a succession of small changes over
it's lifetime that grow the original codebase beyond its foundations.

Work to adapt legacy code is often seen as low priority; maintainers go into a
legacy project with an aim to fix a problem, and stop as soon as they have
evidence that a change has solved it. `If it ain't broke, don't fix it' is an
adage many developers adhere to in maintenance, and this fits with the time
pressure that accompanies these fixes. Robert Glass suggests that changes are
therefore conservative in nature~\cite{softwareConflict}, allowing code to grow
in size but rarely improve in quality over its maintenance lifecycle.

This lack of attention to improvement leads to another quality of maintenance
described by Glass, which is unfairness. Legacy code rarely has any
documentation, especially not on the nuanced changes it has accumulated while
being maintained, despite the lack of such leading to greater difficultly when
the next problem comes around. Tests are also usually missing, causing
developers to lack the confidence that larger refactors demand for software that
is out in production.

Their changes later become the `little hairs and
stuff'~\cite{thingsYouShouldNeverDo} that maintainers are often complaining
about in legacy code. The developers that come after the last maintainer can't
see the time pressure and reasoning that went into the decision, nor understand
to the same level the intricacies of the system they've been asked to modify.
Over time what was clean code with clear architecture has become something
crying for a refactor, but works just well enough to never demand one.

An example of this piecemeal addition~\cite{bigBallOfMud} can be seen in the
\texttt{actionPerformed()} method inside \texttt{JPhotoFrame}, where new actions
have been added until the method is far larger than it was originally intended
to be. In small, incremental steps, \texttt{actionPerformed()} has outgrown what
was a manageable architecture and now dominates the \texttt{JPhotoFrame} class.
Developers have added code in the style that came before them, resistant to
redrawn the boundary lines in case they break was is working software.

While legacy code can sometimes be a nightmare to maintain, it is important to
remember that it is the success stories that come back to haunt us, not the
failures. The lack of context most developers experience when coming to legacy
code is caused by legacy doing its thing, quietly in the corner, without any
errors for a long time. If we had a choice, we are sure we wouldn't want it any
different.

%----------------------------------------------------------------------------------------
%   BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\medskip
\bibliography{lib/refs}
\bibliographystyle{unsrt}
\newpage

\end{document}
